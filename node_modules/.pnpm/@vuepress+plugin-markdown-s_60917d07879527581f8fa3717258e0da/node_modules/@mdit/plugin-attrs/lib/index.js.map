{"version":3,"file":"index.js","sources":["../src/attrs.ts","../src/helper.ts","../src/rules/rules.ts","../src/utils.ts","../src/rules/test.ts","../src/plugin.ts"],"sourcesContent":["import type Token from \"markdown-it/lib/token.mjs\";\n\nimport type { MarkdownItAttrsOptions } from \"./options.js\";\n\nexport type Attr = [key: string, value: string];\n\n// not tab, line feed, form feed, space, solidus, greater than sign, quotation mark, apostrophe and equals sign\nexport const ALLOWED_KEY_CHARS = /[^\\t\\n\\f />\"'=]/;\nexport const PAIR_SEPARATOR = \" \";\nexport const KEY_SEPARATOR = \"=\";\nexport const CLASS_MARKER = \".\";\nexport const ID_MARKER = \"#\";\n\nexport const getAttrs = (\n  str: string,\n  start: number,\n  { left, right, allowed }: Required<Omit<MarkdownItAttrsOptions, \"rule\">>,\n): Attr[] => {\n  let key = \"\";\n  let value = \"\";\n  let parsingKey = true;\n  let valueInsideQuotes = false;\n\n  const attrs: Attr[] = [];\n\n  // read inside {}\n  // start + left delimiter length to avoid beginning {\n  // breaks when } is found or end of string\n  for (let index = start + left.length; index < str.length; index++) {\n    if (str.slice(index, index + right.length) === right) {\n      if (key !== \"\") attrs.push([key, value]);\n      break;\n    }\n\n    const char = str.charAt(index);\n\n    // switch to reading value if equal sign\n    if (char === KEY_SEPARATOR && parsingKey) {\n      parsingKey = false;\n      continue;\n    }\n\n    // {.class} {..css-module}\n    if (char === CLASS_MARKER && key === \"\") {\n      if (str.charAt(index + 1) === CLASS_MARKER) {\n        key = \"css-module\";\n        index++;\n      } else {\n        key = \"class\";\n      }\n\n      parsingKey = false;\n      continue;\n    }\n\n    // {#id}\n    if (char === ID_MARKER && key === \"\") {\n      key = \"id\";\n      parsingKey = false;\n      continue;\n    }\n\n    // {value=\"inside quotes\"}\n    if (char === '\"' && value === \"\") {\n      valueInsideQuotes = true;\n      continue;\n    }\n\n    if (char === '\"' && valueInsideQuotes) {\n      valueInsideQuotes = false;\n      continue;\n    }\n\n    // read next key/value pair\n    if (char === PAIR_SEPARATOR && !valueInsideQuotes) {\n      if (key === \"\")\n        // beginning or ending space: { .red } vs {.red}\n        continue;\n\n      attrs.push([key, value]);\n      key = \"\";\n      value = \"\";\n      parsingKey = true;\n\n      continue;\n    }\n\n    // continue if character not allowed\n    if (parsingKey && char.search(ALLOWED_KEY_CHARS) === -1) continue;\n\n    // no other conditions met; append to key/value\n    if (parsingKey) {\n      key += char;\n      continue;\n    }\n\n    value += char;\n  }\n\n  return allowed.length\n    ? attrs.filter(([attr]) =>\n        allowed.some((item) =>\n          item instanceof RegExp ? item.test(attr) : item === attr,\n        ),\n      )\n    : attrs;\n};\n\nexport const addAttrs = (attrs: Attr[], token: Token | null): void => {\n  if (token)\n    attrs.forEach((attrItem) => {\n      const [key, value] = attrItem;\n\n      if (key === \"class\") token.attrJoin(\"class\", value);\n      else if (key === \"css-module\") token.attrJoin(\"css-module\", value);\n      else token.attrPush(attrItem);\n    });\n};\n","import { escapeRegExp } from \"@mdit/helper\";\nimport type Token from \"markdown-it/lib/token.mjs\";\n\nexport const hasDelimiters =\n  (\n    where: \"start\" | \"end\" | \"only\",\n    left: string,\n    right: string,\n  ): ((content: string) => boolean) =>\n  (content: string): boolean => {\n    const leftLength = left.length;\n    const rightLength = right.length;\n    // we need minimum three chars, for example {b}\n    const minCurlyLength = leftLength + 1 + rightLength;\n\n    if (\n      !content ||\n      typeof content !== \"string\" ||\n      content.length < minCurlyLength\n    )\n      return false;\n\n    const validCurlyLength = (curly: string): boolean => {\n      const isClass = curly.charAt(leftLength) === \".\";\n      const isId = curly.charAt(leftLength) === \"#\";\n\n      return isClass || isId\n        ? curly.length >= minCurlyLength + 1\n        : curly.length >= minCurlyLength;\n    };\n\n    let start, end, slice, nextChar;\n    const rightDelimiterMinimumShift = minCurlyLength - rightLength;\n\n    switch (where) {\n      case \"start\":\n        // first char should be {, } found in char 2 or more\n        slice = content.slice(0, leftLength);\n        start = slice === left ? 0 : -1;\n        end =\n          start === -1\n            ? -1\n            : content.indexOf(right, rightDelimiterMinimumShift);\n        // check if next character is not one of the delimiters\n        nextChar = content.charAt(end + rightLength);\n        if (nextChar && right.includes(nextChar)) end = -1;\n        break;\n\n      case \"end\":\n        // last char should be }\n        start = content.lastIndexOf(left);\n        end =\n          start === -1\n            ? -1\n            : content.indexOf(right, start + rightDelimiterMinimumShift);\n        end = end === content.length - rightLength ? end : -1;\n        break;\n\n      case \"only\":\n        // '{.a}'\n        slice = content.slice(0, leftLength);\n        start = slice === left ? 0 : -1;\n        slice = content.slice(content.length - rightLength);\n        end = slice === right ? content.length - rightLength : -1;\n        break;\n    }\n\n    return (\n      start !== -1 &&\n      end !== -1 &&\n      validCurlyLength(content.substring(start, end + rightLength))\n    );\n  };\n\nexport const removeDelimiter = (\n  str: string,\n  left: string,\n  right: string,\n): string => {\n  const start = escapeRegExp(left);\n  const end = escapeRegExp(right);\n  const pos = str.search(\n    new RegExp(`[ \\\\n]?${start}[^${start}${end}]+${end}$`),\n  );\n\n  return pos !== -1 ? str.slice(0, pos) : str;\n};\n\nexport const getMatchingOpeningToken = (\n  tokens: Token[],\n  index: number,\n): Token | null => {\n  if (tokens[index].type === \"softbreak\") return null;\n\n  // non closing blocks, example img\n  if (tokens[index].nesting === 0) return tokens[index];\n\n  const level = tokens[index].level;\n  const type = tokens[index].type.replace(\"_close\", \"_open\");\n\n  for (; index >= 0; --index)\n    if (tokens[index].type === type && tokens[index].level === level)\n      return tokens[index];\n\n  return null;\n};\n","import { escapeRegExp } from \"@mdit/helper\";\n\nimport type { Rule } from \"./types.js\";\nimport { addAttrs, getAttrs } from \"../attrs.js\";\nimport {\n  getMatchingOpeningToken,\n  hasDelimiters,\n  removeDelimiter,\n} from \"../helper.js\";\nimport type {\n  MarkdownItAttrRuleName,\n  MarkdownItAttrsOptions,\n} from \"../options.js\";\n\nconst getFenceRule = (options: Required<MarkdownItAttrsOptions>): Rule => ({\n  /**\n   * fenced code blocks\n   *\n   * ```python {.cls}\n   * for i in range(10):\n   *     print(i)\n   * ```\n   */\n\n  // fenced code blocks\n  name: \"code-block\",\n  tests: [\n    {\n      shift: 0,\n      block: true,\n      info: hasDelimiters(\"end\", options.left, options.right),\n    },\n  ],\n  transform: (tokens, index): void => {\n    const token = tokens[index];\n    let lineNumber = \"\";\n\n    // special handler for VuePress line number\n    const results = /{(?:[\\d,-]+)}/.exec(token.info);\n\n    if (results) {\n      token.info = token.info.replace(results[0], \"\");\n      lineNumber = results[0];\n    }\n\n    const start = token.info.lastIndexOf(options.left);\n    const attrs = getAttrs(token.info, start, options);\n\n    addAttrs(attrs, token);\n    token.info = `${removeDelimiter(\n      token.info,\n      options.left,\n      options.right,\n    )} ${lineNumber}`;\n  },\n});\n\nconst getInlineRules = (options: Required<MarkdownItAttrsOptions>): Rule[] => [\n  /**\n   * bla `click()`{.c} ![](img.png){.d}\n   *\n   * differs from 'inline attributes' as it does\n   * not have a closing tag (nesting: -1)\n   */\n  {\n    name: \"inline nesting 0\",\n    tests: [\n      {\n        shift: 0,\n        type: \"inline\",\n        children: [\n          {\n            shift: -1,\n            type: (str) => str === \"image\" || str === \"code_inline\",\n          },\n          {\n            shift: 0,\n            type: \"text\",\n            content: hasDelimiters(\"start\", options.left, options.right),\n          },\n        ],\n      },\n    ],\n    transform: (tokens, index, childIndex): void => {\n      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n      const token = tokens[index].children![childIndex];\n\n      const endChar = token.content.indexOf(options.right);\n      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n      const attrToken = tokens[index].children![childIndex - 1];\n      const attrs = getAttrs(token.content, 0, options);\n\n      addAttrs(attrs, attrToken);\n      if (token.content.length === endChar + options.right.length)\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        tokens[index].children!.splice(childIndex, 1);\n      else token.content = token.content.slice(endChar + options.right.length);\n    },\n  },\n\n  /**\n   * *emphasis*{.with attrs=1}\n   */\n  {\n    name: \"inline attributes\",\n    tests: [\n      {\n        shift: 0,\n        type: \"inline\",\n        children: [\n          {\n            shift: -1,\n            nesting: -1, // closing inline tag, </em>{.a}\n          },\n          {\n            shift: 0,\n            type: \"text\",\n            content: hasDelimiters(\"start\", options.left, options.right),\n          },\n        ],\n      },\n    ],\n    transform: (tokens, index, childIndex): void => {\n      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n      const token = tokens[index].children![childIndex];\n      const { content } = token;\n      const attrs = getAttrs(content, 0, options);\n      const openingToken = getMatchingOpeningToken(\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        tokens[index].children!,\n        childIndex - 1,\n      );\n\n      addAttrs(attrs, openingToken);\n      token.content = content.slice(\n        content.indexOf(options.right) + options.right.length,\n      );\n    },\n  },\n];\n\nconst getTableRule = (options: Required<MarkdownItAttrsOptions>): Rule => ({\n  /**\n   * | h1 |\n   * | -- |\n   * | c1 |\n   *\n   * {.c}\n   */\n  name: \"table\",\n  tests: [\n    {\n      // let this token be i, such that for-loop continues at\n      // next token after tokens.splice\n      shift: 0,\n      type: \"table_close\",\n    },\n    {\n      shift: 1,\n      type: \"paragraph_open\",\n    },\n    {\n      shift: 2,\n      type: \"inline\",\n      content: hasDelimiters(\"only\", options.left, options.right),\n    },\n  ],\n  transform: (tokens, index): void => {\n    const token = tokens[index + 2];\n    const tableOpen = getMatchingOpeningToken(tokens, index);\n    const attrs = getAttrs(token.content, 0, options);\n\n    // add attributes\n    addAttrs(attrs, tableOpen);\n    // remove <p>{.c}</p>\n    tokens.splice(index + 1, 3);\n  },\n});\n\nconst getListRules = (options: Required<MarkdownItAttrsOptions>): Rule[] => [\n  /**\n   * - item\n   * {.a}\n   */\n  {\n    name: \"list softbreak\",\n    tests: [\n      {\n        shift: -2,\n        type: \"list_item_open\",\n      },\n      {\n        shift: 0,\n        type: \"inline\",\n        children: [\n          {\n            position: -2,\n            type: \"softbreak\",\n          },\n          {\n            position: -1,\n            type: \"text\",\n            content: hasDelimiters(\"only\", options.left, options.right),\n          },\n        ],\n      },\n    ],\n    transform: (tokens, indx, childIndex): void => {\n      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n      const token = tokens[indx].children![childIndex];\n      const attrs = getAttrs(token.content, 0, options);\n      let ii = indx - 2;\n\n      while (\n        tokens[ii - 1] &&\n        tokens[ii - 1].type !== \"ordered_list_open\" &&\n        tokens[ii - 1].type !== \"bullet_list_open\"\n      )\n        ii--;\n\n      addAttrs(attrs, tokens[ii - 1]);\n      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n      tokens[indx].children = tokens[indx].children!.slice(0, -2);\n    },\n  },\n\n  /**\n   * - nested list\n   *   - with double \\n\n   *   {.a} <-- apply to nested ul\n   *\n   * {.b} <-- apply to root <ul>\n   */\n  {\n    name: \"list double softbreak\",\n    tests: [\n      {\n        // let this token be i = 0 so that we can erase\n        // the <p>{.a}</p> tokens below\n        shift: 0,\n        type: (type) =>\n          type === \"bullet_list_close\" || type === \"ordered_list_close\",\n      },\n      {\n        shift: 1,\n        type: \"paragraph_open\",\n      },\n      {\n        shift: 2,\n        type: \"inline\",\n        content: hasDelimiters(\"only\", options.left, options.right),\n        children: (children) => children.length === 1,\n      },\n      {\n        shift: 3,\n        type: \"paragraph_close\",\n      },\n    ],\n    transform: (tokens, index): void => {\n      const token = tokens[index + 2];\n      const attrs = getAttrs(token.content, 0, options);\n      const openingToken = getMatchingOpeningToken(tokens, index);\n\n      addAttrs(attrs, openingToken);\n      tokens.splice(index + 1, 3);\n    },\n  },\n\n  /**\n   * - end of {.list-item}\n   */\n  {\n    name: \"list item end\",\n    tests: [\n      {\n        shift: -2,\n        type: \"list_item_open\",\n      },\n      {\n        shift: 0,\n        type: \"inline\",\n        children: [\n          {\n            position: -1,\n            type: \"text\",\n            content: hasDelimiters(\"end\", options.left, options.right),\n          },\n        ],\n      },\n    ],\n    transform: (tokens, index, childIndex): void => {\n      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n      const token = tokens[index].children![childIndex];\n      const { content } = token;\n      const attrs = getAttrs(\n        content,\n        content.lastIndexOf(options.left),\n        options,\n      );\n\n      addAttrs(attrs, tokens[index - 2]);\n\n      const trimmed = content.slice(0, content.lastIndexOf(options.left));\n\n      token.content =\n        trimmed[trimmed.length - 1] === \" \" ? trimmed.slice(0, -1) : trimmed;\n    },\n  },\n];\n\nconst getSoftBreakRule = (options: Required<MarkdownItAttrsOptions>): Rule => ({\n  /**\n   * something with softbreak\n   * {.cls}\n   */\n\n  name: \"\\n{.a} softbreak then curly in start\",\n  tests: [\n    {\n      shift: 0,\n      type: \"inline\",\n      children: [\n        {\n          position: -2,\n          type: \"softbreak\",\n        },\n        {\n          position: -1,\n          type: \"text\",\n          content: hasDelimiters(\"only\", options.left, options.right),\n        },\n      ],\n    },\n  ],\n  transform: (tokens, index, childIndex): void => {\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    const token = tokens[index].children![childIndex];\n    const attrs = getAttrs(token.content, 0, options);\n\n    // find last closing tag\n    let ii = index + 1;\n\n    while (tokens[ii + 1] && tokens[ii + 1].nesting === -1) ii++;\n\n    const openingToken = getMatchingOpeningToken(tokens, ii);\n\n    addAttrs(attrs, openingToken);\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    tokens[index].children = tokens[index].children!.slice(0, -2);\n  },\n});\n\nconst getHrRule = (options: Required<MarkdownItAttrsOptions>): Rule => ({\n  /**\n   * horizontal rule --- {#id}\n   */\n  name: \"horizontal rule\",\n  tests: [\n    {\n      shift: 0,\n      type: \"paragraph_open\",\n    },\n    {\n      shift: 1,\n      type: \"inline\",\n      children: (children) => children.length === 1,\n      content: (content) =>\n        new RegExp(\n          `^ {0,3}[-*_]{3,} ?${escapeRegExp(options.left)}[^${escapeRegExp(\n            options.right,\n          )}]`,\n        ).test(content),\n    },\n    {\n      shift: 2,\n      type: \"paragraph_close\",\n    },\n  ],\n  transform: (tokens, index): void => {\n    const token = tokens[index];\n\n    token.type = \"hr\";\n    token.tag = \"hr\";\n    token.nesting = 0;\n\n    const { content } = tokens[index + 1];\n    const start = content.lastIndexOf(options.left);\n    const attrs = getAttrs(content, start, options);\n\n    addAttrs(attrs, token);\n    token.markup = content;\n    tokens.splice(index + 1, 2);\n  },\n});\n\nconst getBlockRule = (options: Required<MarkdownItAttrsOptions>): Rule => ({\n  /**\n   * end of {.block}\n   */\n\n  name: \"end of block\",\n  tests: [\n    {\n      shift: 0,\n      type: \"inline\",\n      children: [\n        {\n          position: -1,\n          content: hasDelimiters(\"end\", options.left, options.right),\n          type: (type) => type !== \"code_inline\" && type !== \"math_inline\",\n        },\n      ],\n    },\n  ],\n  transform: (tokens, indx, childIndex): void => {\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    const token = tokens[indx].children![childIndex];\n    const { content } = token;\n    const attrs = getAttrs(content, content.lastIndexOf(options.left), options);\n    let ii = indx + 1;\n\n    while (tokens[ii + 1] && tokens[ii + 1].nesting === -1) ii++;\n\n    const openingToken = getMatchingOpeningToken(tokens, ii);\n\n    addAttrs(attrs, openingToken);\n\n    const trimmed = content.slice(0, content.lastIndexOf(options.left));\n\n    token.content =\n      trimmed[trimmed.length - 1] === \" \" ? trimmed.slice(0, -1) : trimmed;\n  },\n});\n\nconst availableRules: MarkdownItAttrRuleName[] = [\n  \"fence\",\n  \"inline\",\n  \"table\",\n  \"list\",\n  \"hr\",\n  \"softbreak\",\n  \"block\",\n];\n\nexport const getRules = (options: Required<MarkdownItAttrsOptions>): Rule[] => {\n  const enabledRules =\n    // disable\n    options.rule === false\n      ? []\n      : Array.isArray(options.rule)\n        ? // user specific rules\n          options.rule.filter((item) => availableRules.includes(item))\n        : availableRules;\n\n  const rules: Rule[] = [];\n\n  if (enabledRules.includes(\"fence\")) rules.push(getFenceRule(options));\n  if (enabledRules.includes(\"inline\")) rules.push(...getInlineRules(options));\n  if (enabledRules.includes(\"list\")) rules.push(...getListRules(options));\n  if (enabledRules.includes(\"table\")) rules.push(getTableRule(options));\n  if (enabledRules.includes(\"softbreak\")) rules.push(getSoftBreakRule(options));\n  if (enabledRules.includes(\"hr\")) rules.push(getHrRule(options));\n  if (enabledRules.includes(\"block\")) rules.push(getBlockRule(options));\n\n  return rules;\n};\n","/**\n * Get amount item of array. Supports negative amount, where -1 is last\n * element in array.\n */\nexport const getElements = <T>(arr: T[], amount: number): T =>\n  amount >= 0 ? arr[amount] : arr[arr.length + amount];\n\n// eslint-disable-next-line @typescript-eslint/no-unsafe-function-type\nexport const isArrayOfFunctions = (arr: unknown): arr is Function[] =>\n  Array.isArray(arr) &&\n  Boolean(arr.length) &&\n  arr.every((item) => typeof item === \"function\");\n\nexport const isArrayOfObjects = (arr: unknown): arr is object[] =>\n  Array.isArray(arr) &&\n  Boolean(arr.length) &&\n  arr.every((item) => typeof item === \"object\");\n","import type Token from \"markdown-it/lib/token.mjs\";\n\nimport type { RuleSet } from \"./types.js\";\nimport { getElements, isArrayOfFunctions, isArrayOfObjects } from \"../utils.js\";\n\n/**\n * Test if rule matches token stream.\n *\n */\nexport const testRule = (\n  tokens: Token[],\n  index: number,\n  rule: RuleSet,\n): { match: boolean; position: null | number } => {\n  const res = {\n    match: false,\n    position: null as number | null, // position of child\n  };\n\n  // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n  const ii = rule.shift !== undefined ? index + rule.shift : rule.position!;\n\n  // we should never shift to negative indexes (rolling around to back of array)\n  if (rule.shift !== undefined && ii < 0) return res;\n\n  // supports negative ii\n  const token = getElements(tokens, ii);\n\n  // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n  if (token === undefined) return res;\n\n  for (const key of Object.keys(rule) as (keyof typeof rule)[]) {\n    if (key === \"shift\" || key === \"position\") continue;\n\n    if (token[key as keyof Token] === undefined) return res;\n\n    if (key === \"children\" && isArrayOfObjects(rule.children)) {\n      if (token.children?.length === 0) return res;\n\n      let match;\n      const childTests = rule.children;\n      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n      const children = token.children!;\n\n      if (childTests.every((tt) => tt.position !== undefined)) {\n        // positions instead of shifts, do not loop all children\n        match = childTests.every(\n          // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n          (tt) => testRule(children, tt.position!, tt).match,\n        );\n\n        if (match) {\n          // we may need position of child in transform\n          const j = childTests[childTests.length - 1]?.position ?? 0;\n\n          res.position = j >= 0 ? j : children.length + j;\n        }\n      } else {\n        for (let j = 0; j < children.length; j++) {\n          match = childTests.every((tt) => testRule(children, j, tt).match);\n\n          if (match) {\n            res.position = j;\n            // all tests true, continue with next key of pattern t\n            break;\n          }\n        }\n      }\n\n      if (match === false) return res;\n\n      continue;\n    }\n\n    const ruleDetail = rule[key];\n\n    switch (typeof ruleDetail) {\n      case \"boolean\":\n      case \"number\":\n      case \"string\":\n        if (token[key] !== ruleDetail) return res;\n\n        break;\n\n      case \"function\":\n        // @ts-expect-error: ruleDetail is a function\n        if (!ruleDetail(token[key])) return res;\n\n        break;\n\n      case \"object\":\n        if (isArrayOfFunctions(ruleDetail)) {\n          const r = ruleDetail.every((tt) =>\n            (tt as (key: unknown) => boolean)(token[key]),\n          );\n\n          if (!r) return res;\n\n          break;\n        }\n\n        continue;\n\n      // fall through for objects !== arrays of functions\n      default:\n        throw new Error(\n          `Unknown type of pattern test (key: ${key}). Test should be of type boolean, number, string, function or array of functions.`,\n        );\n    }\n  }\n\n  // no tests returned false -> all tests returns true\n  res.match = true;\n\n  return res;\n};\n","/**\n * Forked and modified from https://github.com/arve0/markdown-it-attrs/\n */\n\nimport type { PluginWithOptions } from \"markdown-it\";\nimport type { RuleCore } from \"markdown-it/lib/parser_core.mjs\";\n\nimport type { MarkdownItAttrsOptions } from \"./options.js\";\nimport { getRules, testRule } from \"./rules/index.js\";\n\nexport const attrs: PluginWithOptions<MarkdownItAttrsOptions> = (\n  md,\n  { left = \"{\", right = \"}\", allowed = [], rule = \"all\" } = {},\n) => {\n  const rules = getRules({\n    left,\n    right,\n    allowed,\n    rule,\n  });\n\n  const attrsRule: RuleCore = ({ tokens }) => {\n    for (let index = 0; index < tokens.length; index++)\n      for (let ruleIndex = 0; ruleIndex < rules.length; ruleIndex++) {\n        const pattern = rules[ruleIndex];\n        // position of child with offset 0\n        let position: null | number = null;\n\n        const match = pattern.tests.every((t) => {\n          const result = testRule(tokens, index, t);\n\n          if (result.position !== null) ({ position } = result);\n\n          return result.match;\n        });\n\n        if (match) {\n          // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n          pattern.transform(tokens, index, position!);\n\n          if (\n            pattern.name === \"inline attributes\" ||\n            pattern.name === \"inline nesting 0\"\n          )\n            // retry, may be several inline attributes\n            ruleIndex--;\n        }\n      }\n  };\n\n  md.core.ruler.before(\"linkify\", \"attrs\", attrsRule);\n};\n"],"names":["ALLOWED_KEY_CHARS","PAIR_SEPARATOR","KEY_SEPARATOR","CLASS_MARKER","ID_MARKER","getAttrs","str","start","left","right","allowed","key","value","parsingKey","valueInsideQuotes","attrs","index","char","attr","item","addAttrs","token","attrItem","hasDelimiters","where","content","leftLength","rightLength","minCurlyLength","validCurlyLength","curly","isClass","isId","end","slice","nextChar","rightDelimiterMinimumShift","removeDelimiter","escapeRegExp","pos","getMatchingOpeningToken","tokens","level","type","getFenceRule","options","lineNumber","results","getInlineRules","childIndex","endChar","attrToken","openingToken","getTableRule","tableOpen","getListRules","indx","ii","children","trimmed","getSoftBreakRule","getHrRule","getBlockRule","availableRules","getRules","enabledRules","rules","getElements","arr","amount","isArrayOfFunctions","isArrayOfObjects","testRule","rule","res","match","childTests","tt","j","ruleDetail","md","attrsRule","ruleIndex","pattern","position","t","result"],"mappings":"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"}